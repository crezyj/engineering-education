
### Fibonacci Numbers Concurrently in Python – How to Calculate Them

What’s so special about Fibonacci numbers? Well, they can be used to calculate other mathematical problems, but they also have their own fascinating properties that don’t apply to other types of numbers. One of these properties is recursion, and it’s used to calculate Fibonacci numbers concurrently in Python using the fastest available algorithms today. What does that mean? It means that you can find the nth Fibonacci number using far fewer computational steps than you might think! Here’s how you can do it too!
### Table of Content
- Calculating Fibonacci numbers concurrently
- Adding Items
- Subtracting Items
- Multiplying Two Fibo Numbers
- Finding the sum of two Fibo numbers

### Prerequisites
- written Code using Python 3.6.2 and is compatible with all versions above it (Python 2 support dropped in version 3).
-  It requires basic knowledge of asyncio 
- Experienced in using python libraries.
### Calculating Fibonacci numbers concurrently
In most programming languages, calculation of Fibonacci numbers is sequential. However, we can calculate them concurrently if we know how many Fibonacci numbers we are calculating and their values. For example, consider a program that calculates first 5 Fibonacci numbers. It is evident that there will be no more than 5 calls to function fib(n) since n=0..4 so we can run fib(0), fib(1), fib(2), fib(3) and fib(4) in parallel. The following example shows you how to do it in Python #!/usr/bin/env python # -*- coding: utf-8 -*-  Calculating Fibonacci numbers concurrently  import time def fib(n): global count count += 1 return count print Calculating Fibonacci numbers concurrently start = time.time() for i in range(5): print i, fib(i) end = time.time() print Time taken:, end - start print Number of calls:, count Output 0 1 1 2 3 2 3 4 5 3 5 8 13 4 8 21 34 5 13 34 55 Time taken: 0.0006 Number of calls: 6 This output shows us that running all these functions concurrently took only 0.0006 seconds and total number of calls was 6 which means that all functions were called at least once by main thread. Here I am using range(5) instead of writing out every number explicitly because they would take up too much space. When I want to iterate over multiple numbers then it’s better to use range instead of writing out every single value.

### Adding Items
The Fibonacci Sequence is a classic numerical series with many interesting properties and algorithms that have been developed around it. Fibonacci numbers are defined by adding up each pair of consecutive numbers starting with 1 and 2: 1, 2, 3, 5, 8, 13, 21... The sequence appears everywhere in nature (in animal populations) because it approximates growth at an exponential rate. These kinds of calculations can be done using simple techniques like loops or recursion. However, if you’re working on a multi-core machine then you can speed things up by calculating them concurrently. This tutorial will show you how to do just that. We’ll start by discussing what concurrency means and why it makes sense for us to use multiple cores when calculating these numbers. Then we’ll look at some simple solutions before moving onto our final example which uses asyncio, a library for handling asynchronous I/O operations used heavily in Python 3 applications. Asyncio allows us to calculate our fibonacci numbers concurrently without worrying about managing threads or locks—as long as we stick to its API! This post was written using Python 3.6.2 and is compatible with all versions above it (Python 2 support dropped in version 3). It requires basic knowledge of asyncio but isn’t dependent on any other external libraries besides NumPy, which is installed automatically with Anaconda.

### Subtracting Items
In order to calculate Fibonacci numbers concurrently, first you must subtract one number from another: A-B=C. To perform subtraction concurrently, you’ll need a thread for each Fibonacci number. Each thread will be responsible for computing two numbers simultaneously: its own value and that of its predecessor. Start by writing a function called fib(n) that returns nth Fibonacci number; it should take n as an argument and return F(n-1)+F(n-2). Now create three threads: one for F(0), one for F(1), and one for F(2). Have them compute their values while communicating with each other via shared memory. The next step is to have these threads communicate with each other—but how? Here’s where channels come into play. Channels are used to pass messages between threads, allowing them to synchronize their work without getting stuck waiting on each other. Create a channel named fibo_channel and have your threads send messages through it when they want to share data or synchronize operations. Now that all three threads can talk to each other, add code to make them do so. You could use message queues (the standard way of implementing concurrency in Python) but we won’t go into detail here because we don’t think it adds much value for such a simple example.

### Multiplying Two Fibo Numbers
If you’re trying to calculate a number, there are two ways that you can multiply two numbers together. The first way is by using regular multiplication. However, if you have a bunch of math problems that involve multiplying by Fibo numbers, then it can be a lot easier and faster for your computer (or yourself) if you’re able to use a technique called fibonacci parallel computation. With fibonacci parallel computation, instead of having one computer work on each step of calculating a number, you’ll be able to split up your problem into multiple parts so that multiple computers can work on each part simultaneously. This makes things much quicker and more efficient when calculating large sets of Fibo numbers. While we won’t get into how to implement parallel computing here, we will take a look at how to write some basic code that uses Fibonacci numbers. For example:
- Write out all of your Fibonacci numbers from 0 through 15 on a piece of paper. Make sure they are in sequential order from 0 through 15; if not, move them around until they are ordered correctly.

### Finding the sum of two Fibo numbers
One easy way of adding two Fibonacci numbers is based on their relation with sums of previous Fibo numbers. This property provides us with a formula that can be applied for finding each element, without having to calculate all previous elements. The approach I am going to describe is good for illustrative purposes only and should not be used for real-world applications, due to its heavy computational complexity. We will start by calculating a Fibonacci number as follows: Let’s say we want to find F(3). We know that it is equal to 2 + 3 = 5. And since we know that each next number after 1 is equal to sum of previous two numbers (1 = 1, 2 = 1 + 1, 3 = 2 + 1), we can deduce that 5 must be equal to 2 + 3 = 5. So, if we take a look at our formula, we can see that if n equals 3 then F(n) must be equal to n * (n - 1) / 2. So far so good. Now let’s try and figure out how many steps do we need to calculate any given Fibonacci number? Well, let’s see what happens when you apply our formula with n = 0 or n = 1? In both cases, we get an error because division by zero is undefined. But from now on everything works like a charm! For example, if you use our formula with n = 2 then you get F(2) = (2 * 1) / 2 = 1. If you use it with n = 3 then you get F(3) = (3 * 2) / 2 = 6 and so forth... As expected, each time we double one number in our calculation result becomes twice as big. That means that if we have N elements to add then we need log_2(N) steps to complete our task. Since log_2(N) ~= N/log_2(N), it means that in order for us to successfully calculate N elements, we need O((log_2(N))^O(1)) operations which makes no sense at all!

### Conclusion
Fibonacci numbers are integers which follow a particular pattern. The first two Fibonacci numbers are 0 and 1, and each subsequent number is equal to the sum of two preceding ones. This pattern continues as far as needed; however, computing many such values concurrently can become time-consuming. To solve this problem, we wrote a program using several concurrent functions in Python 3.2. 3. We then discussed how to execute multiple functions at once and take advantage of some unique aspects of Python’s syntax. We concluded by showing how we can easily extend our solution to work with any length sequence desired. While most solutions will use recursion, ours uses no loops at all!
